package com.project.laundryappui;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.Toolbar;
import androidx.cardview.widget.CardView;

import android.Manifest;
import android.annotation.SuppressLint;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.location.Address;
import android.location.Geocoder;
import android.location.Location;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.provider.Settings;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationServices;
import com.google.android.material.floatingactionbutton.FloatingActionButton;

import org.osmdroid.api.IMapController;
import org.osmdroid.config.Configuration;
import org.osmdroid.events.MapEventsReceiver;
import org.osmdroid.events.MapListener;
import org.osmdroid.events.ScrollEvent;
import org.osmdroid.events.ZoomEvent;
import org.osmdroid.tileprovider.tilesource.TileSourceFactory;
import org.osmdroid.util.GeoPoint;
import org.osmdroid.views.MapView;
import org.osmdroid.views.overlay.MapEventsOverlay;

import java.io.IOException;
import java.util.List;
import java.util.Locale;

/**
 * Activity cho phép người dùng chọn vị trí trên bản đồ OpenStreetMap
 * Sử dụng OSMDroid để hiển thị bản đồ miễn phí, không cần API key
 */
public class MapLocationPickerActivity extends AppCompatActivity implements MapEventsReceiver {

    private static final String TAG = "MapLocationPickerActivity";
    private static final int LOCATION_PERMISSION_REQUEST_CODE = 1001;

    // UI Components
    private Toolbar toolbar;
    private MapView mapView;
    private CardView locationInfoCard;
    private TextView tvSelectedAddress, tvCoordinates, tvBottomAddress;
    private Button btnConfirmLocation;
    private FloatingActionButton fabCurrentLocation;

    // Location Services
    private FusedLocationProviderClient fusedLocationClient;
    private IMapController mapController;

    // Map State
    private GeoPoint selectedLocation = null;
    private GeoPoint currentLocation = null;
    private boolean isLocationSelected = false;

    // Reverse Geocoding
    private Handler geocodingHandler = new Handler(Looper.getMainLooper());
    private Runnable geocodingRunnable;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_map_location_picker);

        // Initialize OSMDroid configuration
        Configuration.getInstance().setUserAgentValue(getPackageName());

        initializeViews();
        setupToolbar();
        setupMap();
        setupClickListeners();
        requestLocationPermission();

        // Check if there's an initial location passed from caller
        handleIntentExtras();
    }

    private void initializeViews() {
        toolbar = findViewById(R.id.toolbar);
        mapView = findViewById(R.id.map_view);
        locationInfoCard = findViewById(R.id.location_info_card);
        tvSelectedAddress = findViewById(R.id.tv_selected_address);
        tvCoordinates = findViewById(R.id.tv_coordinates);
        tvBottomAddress = findViewById(R.id.tv_bottom_address);
        btnConfirmLocation = findViewById(R.id.btn_confirm_location);
        fabCurrentLocation = findViewById(R.id.fab_current_location);

        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this);
    }

    private void setupToolbar() {
        setSupportActionBar(toolbar);
        if (getSupportActionBar() != null) {
            getSupportActionBar().setDisplayHomeAsUpEnabled(true);
            getSupportActionBar().setDisplayShowHomeEnabled(true);
        }
        toolbar.setNavigationOnClickListener(v -> finish());
    }

    private void setupMap() {
        // Configure MapView
        mapView.setTileSource(TileSourceFactory.MAPNIK);
        mapView.setMultiTouchControls(true);
        mapView.getZoomController().setVisibility(
                org.osmdroid.views.CustomZoomButtonsController.Visibility.SHOW_AND_FADEOUT
        );

        mapController = mapView.getController();
        mapController.setZoom(15.0);

        // Add map events overlay to handle tap events
        MapEventsOverlay mapEventsOverlay = new MapEventsOverlay(this);
        mapView.getOverlays().add(0, mapEventsOverlay);

        // Add map listener for scroll/zoom events
        mapView.addMapListener(new MapListener() {
            @Override
            public boolean onScroll(ScrollEvent event) {
                updateLocationFromMapCenter();
                return true;
            }

            @Override
            public boolean onZoom(ZoomEvent event) {
                return false;
            }
        });

        // Default center location (Hồ Chí Minh City, Vietnam)
        GeoPoint defaultLocation = new GeoPoint(10.762622, 106.660172);
        mapController.setCenter(defaultLocation);
    }

    private void setupClickListeners() {
        // FAB to center on current location
        fabCurrentLocation.setOnClickListener(v -> centerOnCurrentLocation());

        // Confirm location button
        btnConfirmLocation.setOnClickListener(v -> confirmLocation());
    }

    private void handleIntentExtras() {
        Intent intent = getIntent();
        if (intent != null) {
            double lat = intent.getDoubleExtra("latitude", 0);
            double lng = intent.getDoubleExtra("longitude", 0);
            if (lat != 0 && lng != 0) {
                selectedLocation = new GeoPoint(lat, lng);
                centerMapToLocation(selectedLocation, 16.0);
                updateLocationInfo(selectedLocation);
                isLocationSelected = true;
                updateConfirmButton();
            }
        }
    }

    private void requestLocationPermission() {
        if (checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            requestPermissions(
                    new String[]{Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION},
                    LOCATION_PERMISSION_REQUEST_CODE
            );
        } else {
            getCurrentLocation();
        }
    }

    @SuppressLint("MissingPermission")
    private void getCurrentLocation() {
        fabCurrentLocation.setEnabled(false);

        fusedLocationClient.getLastLocation()
                .addOnSuccessListener(this, location -> {
                    fabCurrentLocation.setEnabled(true);

                    if (location != null) {
                        currentLocation = new GeoPoint(location.getLatitude(), location.getLongitude());
                        Log.d(TAG, "Current location: " + location.getLatitude() + ", " + location.getLongitude());

                        // Only center if no location was previously selected
                        if (!isLocationSelected) {
                            centerMapToLocation(currentLocation, 16.0);
                        }
                    } else {
                        Log.w(TAG, "Could not get current location");
                        Toast.makeText(this, "Không thể lấy vị trí hiện tại", Toast.LENGTH_SHORT).show();
                    }
                })
                .addOnFailureListener(e -> {
                    fabCurrentLocation.setEnabled(true);
                    Log.e(TAG, "Error getting current location", e);
                    Toast.makeText(this, "Lỗi khi lấy vị trí: " + e.getMessage(), Toast.LENGTH_SHORT).show();
                });
    }

    private void centerOnCurrentLocation() {
        if (currentLocation != null) {
            centerMapToLocation(currentLocation, 16.0);
            updateLocationInfo(currentLocation);
            isLocationSelected = true;
            updateConfirmButton();
        } else {
            // Try to get current location again
            getCurrentLocation();
        }
    }

    private void centerMapToLocation(GeoPoint location, double zoom) {
        mapController.setZoom(zoom);
        mapController.animateTo(location);
    }

    private void updateLocationFromMapCenter() {
        if (mapView != null) {
            GeoPoint center = (GeoPoint) mapView.getMapCenter();
            updateLocationInfo(center);
            isLocationSelected = true;
            updateConfirmButton();
        }
    }

    private void updateLocationInfo(GeoPoint location) {
        selectedLocation = location;

        // Update coordinates display
        tvCoordinates.setText(String.format(Locale.getDefault(),
                "%.6f, %.6f", location.getLatitude(), location.getLongitude()));

        // Show info card
        locationInfoCard.setVisibility(View.VISIBLE);

        // Perform reverse geocoding with debounce
        performReverseGeocoding(location);
    }

    private void performReverseGeocoding(GeoPoint location) {
        // Cancel previous geocoding request
        if (geocodingRunnable != null) {
            geocodingHandler.removeCallbacks(geocodingRunnable);
        }

        // Debounce geocoding requests (wait 500ms after last change)
        geocodingRunnable = () -> {
            try {
                Geocoder geocoder = new Geocoder(this, Locale.getDefault());
                List<Address> addresses = geocoder.getFromLocation(
                        location.getLatitude(),
                        location.getLongitude(),
                        1
                );

                runOnUiThread(() -> {
                    if (addresses != null && !addresses.isEmpty()) {
                        Address address = addresses.get(0);
                        String addressText = buildAddressString(address);
                        tvSelectedAddress.setText(addressText);
                        tvBottomAddress.setText(addressText);
                    } else {
                        String fallbackText = getString(R.string.location_selected) +
                                String.format(Locale.getDefault(), " (%.6f, %.6f)",
                                        location.getLatitude(), location.getLongitude());
                        tvSelectedAddress.setText(fallbackText);
                        tvBottomAddress.setText(fallbackText);
                    }
                });

            } catch (IOException e) {
                Log.e(TAG, "Error in reverse geocoding", e);
                runOnUiThread(() -> {
                    tvSelectedAddress.setText("Không thể xác định địa chỉ");
                    tvBottomAddress.setText("Không thể xác định địa chỉ");
                });
            }
        };

        geocodingHandler.postDelayed(geocodingRunnable, 500);
    }

    private String buildAddressString(Address address) {
        StringBuilder sb = new StringBuilder();

        // Try to build a readable address
        if (address.getAddressLine(0) != null) {
            sb.append(address.getAddressLine(0));
        } else {
            // Fallback to components
            if (address.getLocality() != null) {
                sb.append(address.getLocality());
            }
            if (address.getSubAdminArea() != null) {
                if (sb.length() > 0) sb.append(", ");
                sb.append(address.getSubAdminArea());
            }
            if (address.getAdminArea() != null) {
                if (sb.length() > 0) sb.append(", ");
                sb.append(address.getAdminArea());
            }
            if (address.getCountryName() != null) {
                if (sb.length() > 0) sb.append(", ");
                sb.append(address.getCountryName());
            }
        }

        return sb.toString();
    }

    private void updateConfirmButton() {
        btnConfirmLocation.setEnabled(isLocationSelected);
    }

    private void confirmLocation() {
        if (selectedLocation == null) {
            Toast.makeText(this, "Vui lòng chọn vị trí trước", Toast.LENGTH_SHORT).show();
            return;
        }

        // Return result to calling activity
        Intent resultIntent = new Intent();
        resultIntent.putExtra("latitude", selectedLocation.getLatitude());
        resultIntent.putExtra("longitude", selectedLocation.getLongitude());
        resultIntent.putExtra("address", tvBottomAddress.getText().toString());

        setResult(RESULT_OK, resultIntent);
        finish();
    }

    @Override
    public boolean singleTapConfirmedHelper(GeoPoint p) {
        // Handle single tap on map
        updateLocationInfo(p);
        isLocationSelected = true;
        updateConfirmButton();
        return true;
    }

    @Override
    public boolean longPressHelper(GeoPoint p) {
        // Handle long press on map (same as single tap for selection)
        updateLocationInfo(p);
        isLocationSelected = true;
        updateConfirmButton();
        return true;
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);

        if (requestCode == LOCATION_PERMISSION_REQUEST_CODE) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                getCurrentLocation();
            } else {
                Toast.makeText(this, getString(R.string.location_permission_required), Toast.LENGTH_LONG).show();

                // Show dialog to enable GPS
                showEnableGPSDialog();
            }
        }
    }

    private void showEnableGPSDialog() {
        new AlertDialog.Builder(this)
                .setTitle(getString(R.string.enable_gps_title))
                .setMessage(getString(R.string.enable_gps_message))
                .setPositiveButton(getString(R.string.enable_gps_positive), (dialog, which) -> {
                    Intent intent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                    startActivity(intent);
                })
                .setNegativeButton(getString(R.string.enable_gps_negative), null)
                .show();
    }

    @Override
    public void onResume() {
        super.onResume();
        if (mapView != null) {
            mapView.onResume();
        }
    }

    @Override
    public void onPause() {
        super.onPause();
        if (mapView != null) {
            mapView.onPause();
        }

        // Cancel any pending geocoding
        if (geocodingRunnable != null) {
            geocodingHandler.removeCallbacks(geocodingRunnable);
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mapView != null) {
            mapView.onDetach();
        }
    }
}
